<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/17/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/03/17/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="动态内存基础"><a href="#动态内存基础" class="headerlink" title="动态内存基础"></a>动态内存基础</h2><p>栈内存：局部性、对象自动销毁</p><p>堆内存：运行期动态扩展、需要显式释放</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="动态内存的相关内容"><a href="#动态内存的相关内容" class="headerlink" title="动态内存的相关内容"></a>动态内存的相关内容</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/06/MIT6.824/"/>
    <url>/2024/03/06/MIT6.824/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实验组成：</p><p>lab1—Mapduce</p><p>lab2—Raft</p><p>lab3—k&#x2F;v server</p><p>lab4—分片的key-value服务</p><p>基础架构：</p><p>stroage存储 </p><p>Communition通信</p><p>Computation计算</p><p>关键点</p><p>RPC（远程过程调用）、threads、锁</p><p>Performance性能：scalability(可扩展性)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/05/pro_define/"/>
    <url>/2024/03/05/pro_define/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言性能"><a href="#C-语言性能" class="headerlink" title="C++语言性能"></a>C++语言性能</h1><p>特点如下：</p><p>1、不确定大端法还是小端法，原因：与底层硬件紧密结合</p><p>2、对象生命周期的精确控制</p><p>3、Zero-overhead  abstraction</p><p>包括两点：</p><p>虚函数（不需要为没有使用的语言特性付出成本）</p><p>仅用某些函数特性不会额外付出性能（被编译器优化了）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>听课笔记</title>
    <link href="/2024/01/06/net-work/"/>
    <url>/2024/01/06/net-work/</url>
    
    <content type="html"><![CDATA[<h1 id="P39类型转换："><a href="#P39类型转换：" class="headerlink" title="P39类型转换："></a>P39类型转换：</h1><h2 id="1、注意区别-类型提升、类型转换"><a href="#1、注意区别-类型提升、类型转换" class="headerlink" title="1、注意区别 类型提升、类型转换"></a>1、注意区别 类型提升、类型转换</h2><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">void</span> *v =ptr;<br><br><span class="hljs-type">int</span> *ptr2=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(v)<br></code></pre></td></tr></table></figure><p>对于安全的显示类型转换 有 dynamic_cast</p><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>对于常量型指针,转化为非常量型的指针，但是仍是不安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr;<br><br><span class="hljs-keyword">const_cast</span> &lt;<span class="hljs-type">int</span>*&gt;(ptr);<br></code></pre></td></tr></table></figure><p>对于常量型引用，切记引用的最初，就应该是变量而不是常量，像这种常量，能过编译器，但是还是存在问题。</p><img src="https://pic.imgdb.cn/item/659cfb70871b83018a963025.png" alt="image-20240108110427548.png"><p>系统输出3，而不是4，因为系统直接进行替换，而不是修改。</p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">reinterpret_cast</span>&lt;&gt;()<span class="hljs-comment">//用于重新解释</span><br></code></pre></td></tr></table></figure><p>请注意，这里的重新解释，针对指针，而不是普通变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> *ptr=&amp;x;<br><span class="hljs-type">double</span> *ptr2=<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(ptr);<span class="hljs-comment">//这就相当于将地址变量补位了，double类型会变，float类型不会变，但是均不是我想要的</span><br></code></pre></td></tr></table></figure><h2 id="5、C类型转换"><a href="#5、C类型转换" class="headerlink" title="5、C类型转换"></a>5、C类型转换</h2><p>(double)3 这就是C类型转换，系统就会依次性的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">static_cast</span>,<br><span class="hljs-built_in">static_cast</span>(扩展)+<span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>+<span class="hljs-keyword">const_cast</span>.<br></code></pre></td></tr></table></figure><h1 id="P40算术操作符"><a href="#P40算术操作符" class="headerlink" title="P40算术操作符"></a>P40算术操作符</h1><h2 id="1、一元操作符（有关于数据类型）"><a href="#1、一元操作符（有关于数据类型）" class="headerlink" title="1、一元操作符（有关于数据类型）"></a>1、一元操作符（有关于数据类型）</h2><p>int a[3]&#x3D;{1,2,3};</p><p>const auto &amp;x&#x3D;+a;</p><p>这样的话，解释过来，int * const &amp; x &#x3D; +a;</p><p>请注意  顺序依次是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x=a;<br><span class="hljs-keyword">auto</span> &amp;x=a;<br><span class="hljs-keyword">auto</span> &amp;x=+a;<span class="hljs-comment">//这样会编译错误</span><br>必须是<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;x=+a <span class="hljs-comment">// int * const &amp; x = +a;</span><br>如果没有+<br>解释出来后，就出现了<span class="hljs-type">int</span> <span class="hljs-type">const</span> （&amp;x）[<span class="hljs-number">3</span>]=a;也就是没有类型转换了<br></code></pre></td></tr></table></figure><h2 id="2、一元操作符（整数类型提升，integral-promotion）"><a href="#2、一元操作符（整数类型提升，integral-promotion）" class="headerlink" title="2、一元操作符（整数类型提升，integral promotion）"></a>2、一元操作符（整数类型提升，integral promotion）</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">short <span class="hljs-attribute">x</span>=3;<br>auto <span class="hljs-attribute">y</span>=+3;//此时，int y= static_cast&lt;int&gt; (x);<br></code></pre></td></tr></table></figure><h2 id="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"><a href="#3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作" class="headerlink" title="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"></a>3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作</h2><h2 id="4、满足（m-n-m-n-m"><a href="#4、满足（m-n-m-n-m" class="headerlink" title="4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m"></a>4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m</h2><h1 id="P48-语句基础"><a href="#P48-语句基础" class="headerlink" title="P48 语句基础"></a>P48 语句基础</h1><h2 id="1、顺序语句和非顺序语句"><a href="#1、顺序语句和非顺序语句" class="headerlink" title="1、顺序语句和非顺序语句"></a>1、顺序语句和非顺序语句</h2><p>一般来讲,顺序语句（硬件流水线有关）会比非顺序语句执行速度快</p><h2 id="2、典型非顺序语句：goto"><a href="#2、典型非顺序语句：goto" class="headerlink" title="2、典型非顺序语句：goto"></a>2、典型非顺序语句：goto</h2><p>不能跨函数跳转 、向前跳转不能越过对象初始化语句、向后跳转（向后是指向上）可能会导致对象销毁与重新初始化</p><h2 id="3、分支语句"><a href="#3、分支语句" class="headerlink" title="3、分支语句"></a>3、分支语句</h2><p>稍作特殊记录</p><p>1、这样就是编译器就可以确定,优化了很多部分的代码，所以节省时间，提高了效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> grade =<span class="hljs-number">59</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(grade&lt;<span class="hljs-number">60</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure><p>2、条件框内,可以使用初始化，这样的话变量的生命周期就可控了</p><p>if(int y&#x3D;x*3;y&gt;100)</p><p>&#96;&#96;</p><h2 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h2><p>C++17之后，</p><p>switch(std::cin&gt;&gt;x;x)</p><p>{</p><p>case 4:</p><p>break；</p><p>&#x2F;&#x2F;int y&#x3D;4; 这样是不可以的，因为这是一个整体的Switch代码，是不可以简单的定义的变量。</p><p>&#x2F;&#x2F;但是如果你非得定义，需要大括号</p><p>case 4：</p><p>{</p><p>int y&#x3D;4；</p><p>break；</p><p>}</p><p>case 5：</p><p>break；</p><p>}</p><p>为进一步防止 break缺失引出的问题，我们可以在编译器的设置中添加，Wimplicit-fallthrough</p><p>当然 如果我们希望3执行完后执行4，然后并不需要提醒我，使用[[fallthrough]];即可 （C++17以后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;3&quot;</span>&lt;&lt;std::endl;<br>    [[fallthrough]];<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;4&quot;</span>&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><h2 id="4、while语句"><a href="#4、while语句" class="headerlink" title="4、while语句"></a>4、while语句</h2><p>C语言不可以、C++17之前不行，C++17之后，while（判断条件中可以存在初始化语句）</p><p>再有就是do-while&#x2F;while&#x2F;for三者的细微区别，略过。</p><p>需要注意的是</p><p>for循环中初始化语句，仅可以声明同类型的变量</p><p>请注意（同一行）<br>int x&#x3D;3，*p&#x3D;&x;</p><p>int *x,q;&#x2F;&#x2F;x为指针，但是q是整型int，所以容易存在误解！</p><p>新增部分，基于范围的for循环</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本质：语法糖，编译器会转换为for循环的调用方式（c++17之后，这个转换方式改变了，之前是</p><p>auto _begin&#x3D; 首表达式,   _end&#x3D;尾表达式，上文提到的那个问题，这样声明是可能会存在歧义的。<br>）</p><p><img src="https://pic.imgdb.cn/item/65b8a537871b83018a41c163.jpg"></p><p>看似安全的C++17，范围表达式还是有可能出现问题。</p><p>问题如下：</p><p><img src="https://pic.imgdb.cn/item/65b8b60d871b83018a7480e2.jpg"></p><p>所以C++20开始，在范围表达式之前增加了初始化语句。</p><p>还有一点，使用常量左值引用读元素，</p><ul><li>引用  可以加快遍历速度，不需要拷贝</li><li>常引用，就满足了不会修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>再通俗一点，这里就需要使用</p><p>const auto &amp; v</p><p><strong>但是如果是修改元素，直接去掉const，而使用auto &amp; v,是会报错的，</strong></p><p>举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v = v + <span class="hljs-number">1</span>;<br>std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上没有问题</p><p>以下出现问题，我们使用万能引用来解决这个问题，**<u>auto &amp;&amp;v</u>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector &lt;<span class="hljs-type">bool</span>&gt; arr&#123;<span class="hljs-literal">true</span>，<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v=<span class="hljs-literal">false</span>;<br>&#125;<br>会报错<br>我们应当使用<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;v : arr) &#123;<br>v=<span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-达夫设备—语句的综合应用"><a href="#5-达夫设备—语句的综合应用" class="headerlink" title="5.达夫设备—语句的综合应用"></a>5.达夫设备—语句的综合应用</h2><p>其实也就是switch里面套循环，这里的例子套的循环为for循环</p><p>核心就是switch语句先跳转case处理，那部分特殊的数据（例：不能整除的数据，这里的不能整除指的是100001，每8个进行一次，那个单独的数据），然后后面就是正常的for循环处理可以整除的部分</p><ol><li><p>循环展开,但是容易产生内存越界，举例，如果这里的n是10001，那么i&#x3D;10000时，再次进入循环，执行8次max…,就会产生越界！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>（<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>；i&lt;n; i++）&#123;max... &#125;;<br><br>改为<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i+=<span class="hljs-number">8</span>)      &#123;max... <span class="hljs-number">8</span>次&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>最直观的解决方案就是，0—9999这些，正常处理，但是10000 10001单独处理</p><p>后面单独处理的时候，还可以用指针进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (buffer_count % <span class="hljs-number">8</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h2 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h2><h4 id="1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）"><a href="#1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）" class="headerlink" title="1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）"></a>1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）</h4><h4 id="2、C-函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）"><a href="#2、C-函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）" class="headerlink" title="2、C++函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）"></a>2、C++函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）</h4><p>要使C++语言转为C语言类型，需要在函数声明和函数定义之前均添加 extern “C”</p><p>这样的话，不支持重载、C类型的链接形式这两个特性就支持了。</p><p>提问：如果是函数重载呢？</p><p>答：一个加了extern “C”，另一个不加extern “C”，这样可以发生重载。</p><p>答：两个都加或者两个都不加，这样不可以进行重载。</p><h4 id="3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝"><a href="#3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝" class="headerlink" title="3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝"></a>3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝</h4><p>栈帧结构：函数体所对应的存储结构</p><p><img src="https://pic.imgdb.cn/item/65e6bf539f345e8d03c0d832.jpg"></p><h4 id="4、函数详解部分"><a href="#4、函数详解部分" class="headerlink" title="4、函数详解部分"></a>4、函数详解部分</h4><ul><li><p>零形参用void</p></li><li><p>非模版函数，每个形参有确定的类型，但可以无名称</p></li><li><p>实参到形参的拷贝求值顺序不定</p></li><li><p>C++17中强制省略 临时对象的复制</p></li><li><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Str per)</span></span>&#123;&#125;;+<span class="hljs-built_in">fun</span>(<span class="hljs-built_in">Str</span>());<br></code></pre></td></tr></table></figure></li><li><p>函数传参会产生类型退化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span>;<br>或<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> p[])</span></span>;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">fun</span>(a);<br></code></pre></td></tr></table></figure><p>那如果是二维数组呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> (*ptr) [<span class="hljs-number">4</span>])</span></span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">fun</span>(a);<br><span class="hljs-comment">//当形参部分是int par[100][20]的时候,int a[3][20];fun(a);这样是可以的</span><br><span class="hljs-comment">//但是当int a[3][4]时，就不可以使用fun(a)，因为列的大小不对应。</span><br></code></pre></td></tr></table></figure><p>那如果是引用呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">- <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;par)[<span class="hljs-number">3</span>])</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  </span>&#123;<br><br>  &#125;;<br><br>  <br><br>  <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];<br><br>  <span class="hljs-keyword">auto</span> &amp;b=a;<span class="hljs-comment">//b的类型为 int (&amp;) [3]</span><br><br>  <span class="hljs-built_in">fun</span>(a);<br></code></pre></td></tr></table></figure></li><li><p>最后一点：变长参数</p></li></ul><p>有三种类型</p><p>第一类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(std::initializer_list &lt;<span class="hljs-type">int</span>&gt; par)</span> </span>&#123;<span class="hljs-comment">//使用时，确保类型相同，实质 包含两个指针，开头与结尾</span><br><br>&#125;;<br><br><span class="hljs-built_in">fun</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br></code></pre></td></tr></table></figure><p>第二类 可变长度模版参数</p><p>第三类 使用省略号表示形式参数</p><ul><li><p>函数可以定义缺省实参</p><p>细节：</p><p>若某个形参具有缺省实参，那么它的右侧的形参都必须要有缺省实参</p><p>也即以下是不可以的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>xxx<br><br>&#125;<br></code></pre></td></tr></table></figure><p>缺省实参只能定义一次，例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> fun（<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>,<span class="hljs-type">int</span> z=<span class="hljs-number">3</span>);<span class="hljs-comment">//这里是声明，但是y和z都是缺省实参，都被定义过一次了</span><br></code></pre></td></tr></table></figure><p>在下面的函数定义时，就不可以再次定义y和z的缺省实参了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>,<span class="hljs-type">int</span> z=<span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>xxx;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>那下面这种情况为什么就合法呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z=<span class="hljs-number">3</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>,<span class="hljs-type">int</span> z)</span></span>;<span class="hljs-comment">//因为这里z虽然没有定义缺省实参，但是上一行定义完了z的缺省实参</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>xxx;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在一个翻译单元中，每个形参的缺省实参只能定义一次，比较绕</p><p>缺省实参为对象时，实参的缺省值会随对象值的变化而变化</p></li><li><p>main函数的两个版本</p></li></ul><p>第二个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br></code></pre></td></tr></table></figure><h6 id="argv-0-代表的是调用可执行程序的方式"><a href="#argv-0-代表的是调用可执行程序的方式" class="headerlink" title="argv[0]代表的是调用可执行程序的方式"></a>argv[0]代表的是调用可执行程序的方式</h6><p><img src="https://pic.imgdb.cn/item/65e828f89f345e8d03494845.jpg"></p><h4 id="5、函数体部分详解"><a href="#5、函数体部分详解" class="headerlink" title="5、函数体部分详解"></a>5、函数体部分详解</h4><p>隐式返回&#x2F;显示返回</p><p>显示返回关键字： return</p><h5 id="return"><a href="#return" class="headerlink" title="return ;"></a>return ;</h5><p>return 表达式</p><p>return 初始化列表</p><p>例：</p><p>这段代码的问题在于，<code>std::initializer_list</code> 返回的是一个临时对象，而且它的生命周期是在当前表达式结束后即刻结束。在 <code>fun()</code> 函数返回后，临时的 <code>initializer_list</code> 对象就会被销毁，所以在 <code>main()</code> 函数中使用 <code>auto x = fun();</code> 赋值给 <code>x</code> 的是一个悬空的 <code>initializer_list</code>，使用 <code>x</code> 的行为是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::initializer_list &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">fun</span>()<br>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意  返回自动对象的引用或指针</p><p>返回值优化（RVO） C++17对返回临时对象的强制优化：系统会引入额外的参数，从而省略拷贝构造的过程。</p><p>例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Str <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br>&#123;<br>Str x;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br>int main()<br>&#123;<br>Str res = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//这里其实发生了两次拷贝构造</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、函数的返回类型"><a href="#6、函数的返回类型" class="headerlink" title="6、函数的返回类型"></a>6、函数的返回类型</h4><p>函数返回的几种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">C++<span class="hljs-number">11</span> <span class="hljs-comment">//位于函数头的后部</span><br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> -&gt; <span class="hljs-type">int</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-comment">//初步看没什么不同，但是如果涉及到类的成员函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">S::fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> -&gt; Myint<span class="hljs-comment">//优先在S类内寻找Myint</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-function">S::Myint <span class="hljs-title">S::fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">C++<span class="hljs-number">14</span> <span class="hljs-comment">//自动推导</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//auto的类型是根据return语句来的，如果有多个return语句，要保持一致</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">//如何解决这个问题呢？答：constexpr</span><br><span class="hljs-comment">//例：</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">true</span>;<span class="hljs-comment">//这样的话 编译器根据value的值可以省略一部分，就不会出现多个return语句不一致的问题了</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> 返回类型与结构化绑定（C++17）&#x2F;&#x2F;但并非所有的数据类型都可以结构化绑定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Str</span><br><br>&#123;<br><br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><br>&#125;<br><br><span class="hljs-function">Str <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">return</span> Str&#123;&#125;;<br><br>&#125;<br><br><span class="hljs-keyword">auto</span> [v1,v2] = <span class="hljs-built_in">fun</span>();<span class="hljs-comment">//这里可以直接访问v1，v2</span><br><br></code></pre></td></tr></table></figure><p>[[nodiscard]]属性（C++17）&#x2F;&#x2F;用来提示不应该丢弃返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">[[nodiscard]] int <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int a,int b)</span></span><br>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br>int main()<br>&#123;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、函数重载"><a href="#7、函数重载" class="headerlink" title="7、函数重载"></a>7、函数重载</h4><p>使用相同的函数名定义多个函数，每个函数具有不同的参数列表</p><p>注意：不能基于不同的返回类型进行重载</p><p>name mangling,效果就是产生给编译器看的东西</p><p>重载解析：也即编译器如何选择正确的版本完成函数调用，使我们的函数重载解析时，尽可能的符合常识。</p><p>1、名称查找分为：(有它本身的缺点，例：会限定在域内，相当于固定了查找范围的优先级，可能造成不恰当的调用)</p><ul><li>限定查找：例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">::<span class="hljs-built_in">fun</span>();<span class="hljs-comment">//限定在全局去找，不会深入到类内</span><br>MyNS::<span class="hljs-built_in">fun</span>();<span class="hljs-comment">//限定在类内或域内进行查找</span><br></code></pre></td></tr></table></figure><p>非限定查找 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">fun</span>();<span class="hljs-comment">//直接调用会进行域的逐级查找</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br><span class="hljs-keyword">namespace</span> MyNS<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;xx&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyNS::<span class="hljs-built_in">g</span>();<span class="hljs-comment">//这里会调用到域内还是全局的fun，取决于g()函数和域内fun()函数的相对关系（位置）,实质</span><br>    <span class="hljs-comment">//就是编译器知道的顺序先后</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、实参依赖查找：只对自定义类型生效</p><p>对于重载解析的整体步骤，大致分为两部分</p><p>  <img src="https://pic.imgdb.cn/item/65f1574e9f345e8d03a02da7.png"></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// bool 转 int 就是promotion</span><br><span class="hljs-comment">// 1 转float 或 double 均是标准转换 </span><br></code></pre></td></tr></table></figure><h3 id="8、函数相关的其他内容"><a href="#8、函数相关的其他内容" class="headerlink" title="8、函数相关的其他内容"></a>8、函数相关的其他内容</h3><p>1、递归函数，以二分查找作为例子</p><p>2、内联函数（适用于较为简单的函数，编译器会直接调用展开,就不会涉及到后面的栈帧的建立、销毁）</p><p>即使我不加inline，编译器在针对翻译单元进行操作时，有时编译器也会直接展开函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于编译器而言，内联函数可以被编译器重复接受，并选择其中一个，不会报错</p><p>实质，就是翻译单元也要有一致性原则</p><p>3、constexpr 常量表达式，针对变量或者针对函数，使其在编译器就被确定</p><ul><li>constexpr函数（C++11起），既可以在编译期执行也可以在运行期执行。</li><li>consteval函数（C++20起），只能在编译期运行，强制在编译期执行，可以提升性能，但是函数体中不能出现在运行期间才可以执行的语句。</li></ul><p>数组类型与函数类型的联系与区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> K = <span class="hljs-type">int</span> [<span class="hljs-number">3</span>];<br>K a;<br><br><span class="hljs-keyword">using</span> K =<span class="hljs-built_in">int</span> (<span class="hljs-type">int</span>)<br>K fun;<span class="hljs-comment">//这样声明是可以的，等于int fun(int),但是不能继续定义</span><br><br></code></pre></td></tr></table></figure><p>接下来重点介绍  数组指针类型、函数指针类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> K = <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];<br>K* a;<span class="hljs-comment">//相当于int (*a) [3];一定注意，这里的括号，是不能省略int *a[3]//这样写的话，代表a[3]数组,数组元素的类型为int *</span><br><br><br><span class="hljs-keyword">using</span> K = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>);<br>K * fun;<span class="hljs-comment">//一定要注意，这里的fun，就不再是函数声明、而是变量、而是指针</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">///</span><br>&#125;<br>fun = &amp;dec;<span class="hljs-comment">//这样的话，就有了一个典型的函数指针，调用时就可以使用(*fun) (100)</span><br><span class="hljs-comment">//既然是函数指针，也就可以作为函数的参数</span><br><span class="hljs-comment">//我来写一个高级函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Twice</span><span class="hljs-params">(K *fun,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp=(*fun)(x);<br>    <span class="hljs-keyword">return</span> tmp*<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//再来一个</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">transform</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),a.<span class="hljs-built_in">begin</span>(),&amp;dec);<br><span class="hljs-comment">//相当于就是a数组中的每个元素，依次调用dec函数</span><br></code></pre></td></tr></table></figure><p><strong>4、函数指针与重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-keyword">auto</span> x = fun;<span class="hljs-comment">//这样就会产生歧义</span><br><span class="hljs-comment">//可以改用以下</span><br><span class="hljs-keyword">using</span> K=<span class="hljs-built_in">void</span> (<span class="hljs-type">int</span>)<br>K* x=fun;<br></code></pre></td></tr></table></figure><p><strong>5、函数指针作返回值</strong><br>与数组类似，函数返回与数组返回，均不能返回函数本身、数组本身，因为数组与函数均不可以复制，那么返回的自然是数组指针或者函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">bool</span> input)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(input)<br><span class="hljs-keyword">return</span> inc;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> dec;<br>&#125;<br><br>std::cout&lt;&lt;(*<span class="hljs-built_in">fun</span>(<span class="hljs-literal">true</span>))(<span class="hljs-number">100</span>)&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
