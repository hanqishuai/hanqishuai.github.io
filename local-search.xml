<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/05/pro_define/"/>
    <url>/2024/03/05/pro_define/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>听课笔记</title>
    <link href="/2024/01/06/net-work/"/>
    <url>/2024/01/06/net-work/</url>
    
    <content type="html"><![CDATA[<h1 id="P39类型转换："><a href="#P39类型转换：" class="headerlink" title="P39类型转换："></a>P39类型转换：</h1><h2 id="1、注意区别-类型提升、类型转换"><a href="#1、注意区别-类型提升、类型转换" class="headerlink" title="1、注意区别 类型提升、类型转换"></a>1、注意区别 类型提升、类型转换</h2><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">void</span> *v =ptr;<br><br><span class="hljs-type">int</span> *ptr2=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(v)<br></code></pre></td></tr></table></figure><p>对于安全的显示类型转换 有 dynamic_cast</p><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>对于常量型指针,转化为非常量型的指针，但是仍是不安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr;<br><br><span class="hljs-keyword">const_cast</span> &lt;<span class="hljs-type">int</span>*&gt;(ptr);<br></code></pre></td></tr></table></figure><p>对于常量型引用，切记引用的最初，就应该是变量而不是常量，像这种常量，能过编译器，但是还是存在问题。</p><img src="https://pic.imgdb.cn/item/659cfb70871b83018a963025.png" alt="image-20240108110427548.png"><p>系统输出3，而不是4，因为系统直接进行替换，而不是修改。</p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">reinterpret_cast</span>&lt;&gt;()<span class="hljs-comment">//用于重新解释</span><br></code></pre></td></tr></table></figure><p>请注意，这里的重新解释，针对指针，而不是普通变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> *ptr=&amp;x;<br><span class="hljs-type">double</span> *ptr2=<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(ptr);<span class="hljs-comment">//这就相当于将地址变量补位了，double类型会变，float类型不会变，但是均不是我想要的</span><br></code></pre></td></tr></table></figure><h2 id="5、C类型转换"><a href="#5、C类型转换" class="headerlink" title="5、C类型转换"></a>5、C类型转换</h2><p>(double)3 这就是C类型转换，系统就会依次性的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">static_cast</span>,<br><span class="hljs-built_in">static_cast</span>(扩展)+<span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>+<span class="hljs-keyword">const_cast</span>.<br></code></pre></td></tr></table></figure><h1 id="P40算术操作符"><a href="#P40算术操作符" class="headerlink" title="P40算术操作符"></a>P40算术操作符</h1><h2 id="1、一元操作符（有关于数据类型）"><a href="#1、一元操作符（有关于数据类型）" class="headerlink" title="1、一元操作符（有关于数据类型）"></a>1、一元操作符（有关于数据类型）</h2><p>int a[3]&#x3D;{1,2,3};</p><p>const auto &amp;x&#x3D;+a;</p><p>这样的话，解释过来，int * const &amp; x &#x3D; +a;</p><p>请注意  顺序依次是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x=a;<br><span class="hljs-keyword">auto</span> &amp;x=a;<br><span class="hljs-keyword">auto</span> &amp;x=+a;<span class="hljs-comment">//这样会编译错误</span><br>必须是<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;x=+a <span class="hljs-comment">// int * const &amp; x = +a;</span><br>如果没有+<br>解释出来后，就出现了<span class="hljs-type">int</span> <span class="hljs-type">const</span> （&amp;x）[<span class="hljs-number">3</span>]=a;也就是没有类型转换了<br></code></pre></td></tr></table></figure><h2 id="2、一元操作符（整数类型提升，integral-promotion）"><a href="#2、一元操作符（整数类型提升，integral-promotion）" class="headerlink" title="2、一元操作符（整数类型提升，integral promotion）"></a>2、一元操作符（整数类型提升，integral promotion）</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">short <span class="hljs-attribute">x</span>=3;<br>auto <span class="hljs-attribute">y</span>=+3;//此时，int y= static_cast&lt;int&gt; (x);<br></code></pre></td></tr></table></figure><h2 id="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"><a href="#3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作" class="headerlink" title="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"></a>3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作</h2><h2 id="4、满足（m-n-m-n-m"><a href="#4、满足（m-n-m-n-m" class="headerlink" title="4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m"></a>4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m</h2><h1 id="P48-语句基础"><a href="#P48-语句基础" class="headerlink" title="P48 语句基础"></a>P48 语句基础</h1><h2 id="1、顺序语句和非顺序语句"><a href="#1、顺序语句和非顺序语句" class="headerlink" title="1、顺序语句和非顺序语句"></a>1、顺序语句和非顺序语句</h2><p>一般来讲,顺序语句（硬件流水线有关）会比非顺序语句执行速度快</p><h2 id="2、典型非顺序语句：goto"><a href="#2、典型非顺序语句：goto" class="headerlink" title="2、典型非顺序语句：goto"></a>2、典型非顺序语句：goto</h2><p>不能跨函数跳转 、向前跳转不能越过对象初始化语句、向后跳转（向后是指向上）可能会导致对象销毁与重新初始化</p><h2 id="3、分支语句"><a href="#3、分支语句" class="headerlink" title="3、分支语句"></a>3、分支语句</h2><p>稍作特殊记录</p><p>1、这样就是编译器就可以确定,优化了很多部分的代码，所以节省时间，提高了效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> grade =<span class="hljs-number">59</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(grade&lt;<span class="hljs-number">60</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure><p>2、条件框内,可以使用初始化，这样的话变量的生命周期就可控了</p><p>if(int y&#x3D;x*3;y&gt;100)</p><p>&#96;&#96;</p><h2 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h2><p>C++17之后，</p><p>switch(std::cin&gt;&gt;x;x)</p><p>{</p><p>case 4:</p><p>break；</p><p>&#x2F;&#x2F;int y&#x3D;4; 这样是不可以的，因为这是一个整体的Switch代码，是不可以简单的定义的变量。</p><p>&#x2F;&#x2F;但是如果你非得定义，需要大括号</p><p>case 4：</p><p>{</p><p>int y&#x3D;4；</p><p>break；</p><p>}</p><p>case 5：</p><p>break；</p><p>}</p><p>为进一步防止 break缺失引出的问题，我们可以在编译器的设置中添加，Wimplicit-fallthrough</p><p>当然 如果我们希望3执行完后执行4，然后并不需要提醒我，使用[[fallthrough]];即可 （C++17以后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;3&quot;</span>&lt;&lt;std::endl;<br>    [[fallthrough]];<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;4&quot;</span>&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><h2 id="4、while语句"><a href="#4、while语句" class="headerlink" title="4、while语句"></a>4、while语句</h2><p>C语言不可以、C++17之前不行，C++17之后，while（判断条件中可以存在初始化语句）</p><p>再有就是do-while&#x2F;while&#x2F;for三者的细微区别，略过。</p><p>需要注意的是</p><p>for循环中初始化语句，仅可以声明同类型的变量</p><p>请注意（同一行）<br>int x&#x3D;3，*p&#x3D;&x;</p><p>int *x,q;&#x2F;&#x2F;x为指针，但是q是整型int，所以容易存在误解！</p><p>新增部分，基于范围的for循环</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本质：语法糖，编译器会转换为for循环的调用方式（c++17之后，这个转换方式改变了，之前是</p><p>auto _begin&#x3D; 首表达式,   _end&#x3D;尾表达式，上文提到的那个问题，这样声明是可能会存在歧义的。<br>）</p><p><img src="https://pic.imgdb.cn/item/65b8a537871b83018a41c163.jpg"></p><p>看似安全的C++17，范围表达式还是有可能出现问题。</p><p>问题如下：</p><p><img src="https://pic.imgdb.cn/item/65b8b60d871b83018a7480e2.jpg"></p><p>所以C++20开始，在范围表达式之前增加了初始化语句。</p><p>还有一点，使用常量左值引用读元素，</p><ul><li>引用  可以加快遍历速度，不需要拷贝</li><li>常引用，就满足了不会修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>再通俗一点，这里就需要使用</p><p>const auto &amp; v</p><p><strong>但是如果是修改元素，直接去掉const，而使用auto &amp; v,是会报错的，</strong></p><p>举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v = v + <span class="hljs-number">1</span>;<br>std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上没有问题</p><p>以下出现问题，我们使用万能引用来解决这个问题，**<u>auto &amp;&amp;v</u>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector &lt;<span class="hljs-type">bool</span>&gt; arr&#123;<span class="hljs-literal">true</span>，<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v=<span class="hljs-literal">false</span>;<br>&#125;<br>会报错<br>我们应当使用<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;v : arr) &#123;<br>v=<span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-达夫设备—语句的综合应用"><a href="#5-达夫设备—语句的综合应用" class="headerlink" title="5.达夫设备—语句的综合应用"></a>5.达夫设备—语句的综合应用</h2><p>其实也就是switch里面套循环，这里的例子套的循环为for循环</p><p>核心就是switch语句先跳转case处理，那部分特殊的数据（例：不能整除的数据，这里的不能整除指的是100001，每8个进行一次，那个单独的数据），然后后面就是正常的for循环处理可以整除的部分</p><ol><li><p>循环展开,但是容易产生内存越界，举例，如果这里的n是10001，那么i&#x3D;10000时，再次进入循环，执行8次max…,就会产生越界！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>（<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>；i&lt;n; i++）&#123;max... &#125;;<br><br>改为<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i+=<span class="hljs-number">8</span>)      &#123;max... <span class="hljs-number">8</span>次&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>最直观的解决方案就是，0—9999这些，正常处理，但是10000 10001单独处理</p><p>后面单独处理的时候，还可以用指针进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (buffer_count % <span class="hljs-number">8</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h2 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h2><p>1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）</p><p>2、C++函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）</p><p>要使C++语言转为C语言类型，需要在函数声明和函数定义之前均添加 extern “C”</p><p>这样的话，不支持重载、C类型的链接形式这两个特性就支持了。</p><p>提问：如果是函数重载呢？</p><p>答：一个加了extern “C”，另一个不加extern “C”，这样可以发生重载。</p><p>答：两个都加或者两个都不加，这样不可以进行重载。</p><p>3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝</p><p>栈帧结构：函数体所对应的存储结构</p><p><img src="https://pic.imgdb.cn/item/65e6bf539f345e8d03c0d832.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
