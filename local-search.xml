<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/07/19/moduo%E7%BD%91%E7%BB%9C%E5%BA%93/day1/"/>
    <url>/2024/07/19/moduo%E7%BD%91%E7%BB%9C%E5%BA%93/day1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/05/30/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/30/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型算法：可以支持多种类型的算法"><a href="#泛型算法：可以支持多种类型的算法" class="headerlink" title="泛型算法：可以支持多种类型的算法"></a>泛型算法：可以支持多种类型的算法</h2><h5 id="模板（函数模板-类模板）是C-实现泛型编程的主要机制"><a href="#模板（函数模板-类模板）是C-实现泛型编程的主要机制" class="headerlink" title="模板（函数模板&#x2F;类模板）是C++实现泛型编程的主要机制"></a>模板（函数模板&#x2F;类模板）是C++实现泛型编程的主要机制</h5><p>要注意：</p><p>C++标准库引入了泛型算法而不是方法的形式，即std::sort(,)而不是xxx.sort()</p><p>使用迭代器作为算法和数据的桥梁，从而支持多种类型的算法</p><p>一些泛型算法与方法同名，实现功能类似，此时建议调用方法而非算法</p><p>std::find V.S. std::map::find</p><p>线性 VS 对数查找</p><p>读算法：accumulate累积 find count</p><p>写算法：单纯写：fill &#x2F; fill_n，后者不再使用区间的前后指针，而是使用前指针+写入个数（也即循环次数）</p><p>读+写操作： transform &#x2F; copy，其中( * first ++ )代表先引用，后指针移动一位。</p><p>写操作要确保对应空间要充足!</p><p>排序算法：unique&#x2F;sort</p><p>unique将原序列任意一段连续相同的区间元素，注意不是自动从小到大排序哦，这是在减少重复值，保留唯一一个，注意 多出来的元素不是放到后面而是被覆盖了</p><p>例子：</p><p>1，2，2，3，4</p><p>unique之后，1，2，3，4，4而不是1，2，3，4，2</p><p>后者是不对的，一定是覆盖。</p><p>所以unique是要搭配erase使用的！删除掉后面不应有的元素</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/05/27/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <url>/2024/05/27/%E9%80%82%E9%85%8D%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="四类适配器"><a href="#四类适配器" class="headerlink" title="四类适配器"></a>四类适配器</h1><p>类型适配器、接口适配器、数值适配器、生成器</p><h2 id="1、类型适配器（不同类型统一到一个类型内进行处理）"><a href="#1、类型适配器（不同类型统一到一个类型内进行处理）" class="headerlink" title="1、类型适配器（不同类型统一到一个类型内进行处理）"></a><em><strong>1、类型适配器（不同类型统一到一个类型内进行处理）</strong></em></h2><p>basic_string_view（C++）有很多分类</p><p>其中</p><h4 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h4><p>解决了接口处string类型与char字符串不匹配的问题，也即统一在接口处使用std::string_view,  并不拥有对字符串的实际控制，操作成本低，不需要开辟新内存，只是重新展示一下（就是一个字符串的指针，可以说一个迭代器指向了开头，一个迭代器指向了结尾）。</p><p>大部分作为函数输入参数，而不是函数返回值。</p><p>缺点：<u>不可以进行写操作。</u> </p><h4 id="span-C-20"><a href="#span-C-20" class="headerlink" title="span(C++ 20)"></a>span(C++ 20)</h4><p>可基于C数组、array等构造</p><p><u>可读写</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(std::span&lt;<span class="hljs-type">int</span>&gt; input)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : input)<br>&#123;<br>std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br>&#125;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; s&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="2、接口适配器"><a href="#2、接口适配器" class="headerlink" title="2、接口适配器"></a><em><u><strong>2、接口适配器</strong></u></em></h2><h3 id="stack-queue-priority-queue"><a href="#stack-queue-priority-queue" class="headerlink" title="stack&#x2F;queue&#x2F;priority_queue"></a>stack&#x2F;queue&#x2F;priority_queue</h3><p>对底层序列容器进行封装，对外展现栈、队列与优先级队列的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::stack&lt;<span class="hljs-type">int</span>,std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; p;<br><span class="hljs-comment">//这个就是stack&lt;int&gt; p;的实质</span><br></code></pre></td></tr></table></figure><h2 id="3、数值适配器-（C-20）"><a href="#3、数值适配器-（C-20）" class="headerlink" title="***3、数值适配器***（C++20）"></a>***<u>3、数值适配器</u>***（C++20）</h2><p>std::ranges::XXX_view,</p><p>std::ranges::views::XXX,</p><p>std::views::XXX</p><p>可以将一个输入区间中的值变换后输出</p><p>数值适配器可以组合，引入复杂的数值适配逻辑</p><p>例：std::ranges::filter_view(v,isEven)，相当于满足isEven返回集合v中的值，这就是“过滤”，但不会改变集合本身，这就是视图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-keyword">auto</span> x = std::views::<span class="hljs-built_in">filter</span>(isEven);<br><br><span class="hljs-keyword">auto</span> y = std::views::<span class="hljs-built_in">transform</span>(Square);<br><br><span class="hljs-comment">//或者提前流式操作 auto z=std::views::filter(isEven) | std::views::transform(Square)；</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : v | y | x )<span class="hljs-comment">//管道操作符 | 这就相当于先经过y操作，再经过x操作。</span><br>&#123;<br>std::cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、生成器-（C-20）"><a href="#4、生成器-（C-20）" class="headerlink" title="***4、生成器***（C++20）"></a>***<u>4、生成器</u>***（C++20）</h2><p>运行期生成有限或无限的序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::ranges:itoa_view<br><br>std::ranges::views::itoa<br><br>std::views::itoa<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/30/%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/03/30/%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><ul><li>序列容器：对象有序排列、使用整数值进行索引</li><li>关联容器：其中的对象顺序并不重要，使用键进行索引</li><li>适配器：调整原有容器的行为，使其对外展现出新的类型、接口或返回新的元素</li><li>生成器：构造元素序列</li></ul><h3 id="迭代器分类-5类"><a href="#迭代器分类-5类" class="headerlink" title="迭代器分类 5类"></a>迭代器分类 5类</h3><p>不同的类别支持的操作集合不同</p><ul><li>输入迭代器 <code>std::istream_iterator</code> 就是一种输入迭代器</li><li>输出迭代器 <code>std::ostream_iterator</code> 就是一种输出迭代器</li><li><strong>Forward Iterators（前向迭代器）</strong>在序列中向前和向后移动，且可以多次遍历序列，<code>std::forward_list</code> 的迭代器就是一种前向迭代器 </li><li><strong>Bidirectional Iterators（双向迭代器）</strong><code>std::list</code> 的迭代器就是一种双向迭代器</li><li><strong>Random Access Iterators（随机访问迭代器）</strong>例 <code>std::vector</code> 的迭代器就是一种随机访问迭代器</li></ul><p>迭代器中</p><p>1、cbegin()&#x2F;cend()与begin()&#x2F;end()的区别在于前者构造出来的迭代器是只读的!</p><p>2、crbegin()&#x2F;crend()与rbegin()&#x2F;rend()这里r是反向迭代器的意思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x_start = x.<span class="hljs-built_in">rbegin</span>();<br><span class="hljs-keyword">auto</span> x_end = x.<span class="hljs-built_in">rend</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ptr = x_start;ptr&lt;x_end;ptr++)<br>&#123;<br>    <span class="hljs-comment">//这样遍历，就是从后往前遍历</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请注意：</p><p>当然了，还有容器是没有迭代器的，这样的容器有一些，例：array &#x2F; pair</p><p>对于支持迭代器的容器，我们称之为range</p><h2 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h2><ul><li>array：元素个数固定</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//特点：个数固定、允许复制 arr.at(100)只要超出数组就会崩溃，arr[100]超出数组不一定会崩溃</span><br><br>arr.<span class="hljs-built_in">data</span>()<span class="hljs-comment">//返回一个指向“array”存储元素的连续内存区域的指针。</span><br><br>arr.<span class="hljs-built_in">fill</span>()<span class="hljs-comment">//填充，所有元素均初始化同一个值</span><br><br>arr.<span class="hljs-built_in">swap</span>()<span class="hljs-comment">//容器整体的交换</span><br></code></pre></td></tr></table></figure><ul><li><p>vector:元素连续存储</p><p><img src="https://img2.imgtp.com/2024/04/01/GjmnoL4F.png" alt="1711977566821.png"></p></li></ul><p>特别点：vector不提供push_front&#x2F;pop_front,可以使用insert&#x2F;erase模拟，但效率不高</p><p>swap效率较高</p><ul><li><p>forward_list&#x2F;list 链表&#x2F;双向链表</p><p><strong>注意：list并没有提供像vector容器一样的，数组式的访问方式</strong></p><p>list容器模板：双向链表，与vector相比，插入、删除成本较低，但随机访问成本较高</p><p>提供了pop_front&#x2F;splice等接口</p><p>写操作通常不会改变迭代器的有效性</p><p>forward_list单向链表(一个成本较低的线性表，所以不支持size（），不支持链表尾部的指针)</p><p>只支持递增操作，无rbegin &#x2F; rend</p><p><strong>不支持size（ ）</strong></p><p>不支持pop_back&#x2F;push_back</p></li><li><p>deque：vector与list的折衷</p></li></ul><p><strong>deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域</strong>。</p><p>而且在右侧一段一段的连续空间中，并不一定是满的。  </p><p><img src="https://img2.imgtp.com/2024/04/05/Cj1b8ueO.png" alt="1712285759438.png"></p><ul><li><p><strong>basic_string: 提供了对字符串专门的支持</strong></p><p><code>std::basic_string</code> 是 C++ 标准库中的通用字符串模板类，而 <code>std::string</code> 是<code>std::basic_string&lt;char&gt;</code> 的一个特化版本，用于处理以 <code>char</code> 类型编码的字符串。</p><p>std::basic_string<char>与std::string等价，但std::basic_string&lt;类型&gt;还可以变化</p></li></ul><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>set&#x2F;map&#x2F;multiset&#x2F;multimap底层使用红黑树（比较特殊的平衡二叉搜索树）</p><p>unordered_xxx底层使用hash表实现     </p><p><a href="https://img.qovv.cn/2024/04/08/66135fe515cb9.png"><img src="https://img.qovv.cn/2024/04/08/66135fe515cb9.png" alt="1712546173467.png"></a></p><p>set迭代器所指向的对象是const的，不能通过其修改元素，构造时，元素默认使用＜比较大小，所以输出结果</p><p>就是从小到大，如果要改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::set &lt;<span class="hljs-type">int</span>,std::greater&lt;<span class="hljs-type">int</span>&gt;&gt;  s&#123;<span class="hljs-number">3</span>,<span class="hljs-number">100</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>&#125;;<br></code></pre></td></tr></table></figure><p> 如果要自定义比较容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::set &lt;<span class="hljs-type">int</span>,<span class="hljs-keyword">decltype</span>(&amp;MyComp)&gt;  <span class="hljs-built_in">s</span>(&#123;Str1&#123;&#125;,Str2&#123;&#125;&#125;,MyComp);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MyComp</span><span class="hljs-params">(<span class="hljs-type">const</span> Str&amp; val1,<span class="hljs-type">const</span> Str&amp; val2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val1.x&lt;val2.x;<br>&#125;<br></code></pre></td></tr></table></figure><p>map</p><p><img src="https://img2.imgtp.com/2024/04/17/bIxp2zXU.png" alt="1713357639871.png"></p><p>map使用键值构建红黑树</p><p><strong>map迭代器所指向的对象是std::pair,其键是const类型</strong>,值的类型不管</p><p>所以接收的时候，auto [k,v] 或者说 auto &amp;[k,v]</p><p><strong>[]操作不能用于常量对象</strong></p><p>意思就是说</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> ptr = m.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);`<span class="hljs-comment">//不可以直接使用m[3],这样就相当于在运行期直接调用这个常量对象  </span><br><br>`<span class="hljs-keyword">if</span>(ptr!=m.<span class="hljs-built_in">end</span>())`<br><br>`&#123;`<br><br>`ptr-&gt;second;`<br><br>`&#125;<br></code></pre></td></tr></table></figure><p>multiset和multimap是允许重复的。   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::multiset&lt;<span class="hljs-type">int</span>&gt; s&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;中<br><span class="hljs-keyword">auto</span> b=s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">1</span>);<br>和<br><span class="hljs-built_in">lower_bound</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);<br><span class="hljs-comment">//两者功能相同，第一个是成员函数调用、第二个使用全局函数以及需要提供容器的起始和结束迭代器</span><br><br><span class="hljs-keyword">auto</span> p=s.<span class="hljs-built_in">equal_range</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//直接返回区间的起始迭代器和结束迭代器的pair对</span><br>p.first<br>p.second<br><span class="hljs-comment">//来访问</span><br></code></pre></td></tr></table></figure><p>继续学习关联容器</p><p>unordered_set&#x2F;unordered_map&#x2F;unordered_multiset&#x2F;unordered_multimap</p><p>一定要做好区分</p><p>set&#x2F;multiset&#x2F;unordered_set&#x2F;unordered_multiset</p><p>唯一性&#x2F;</p><p>不唯一但是仍按顺序存储&#x2F;</p><p>唯一性但是使用hash表来存储</p><p>不唯一且使用hash表来存储内容&#x2F;</p><p>以上四者 除&#x3D;&#x3D;，!&#x3D;外，不支持容器级别的关系运算</p><p>但是&#x3D;&#x3D;，!&#x3D;速度较慢</p><h2 id="自定义hash与判等函数-如下："><a href="#自定义hash与判等函数-如下：" class="headerlink" title="自定义hash与判等函数, 如下："></a>自定义hash与判等函数, 如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Strr</span><br><br>&#123;<br><br>  <span class="hljs-type">int</span> x;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">myhash</span><span class="hljs-params">(<span class="hljs-type">const</span> Strr&amp; val)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-keyword">return</span> val.x;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> Strr&amp; val1,<span class="hljs-type">const</span> Strr&amp; val2)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-keyword">return</span> val1.x==val2.x;<br><br>&#125;<br><br> <span class="hljs-function">std::unordered_set&lt;Strr,<span class="hljs-title">decltype</span><span class="hljs-params">(&amp;myhash)</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(&amp;myEqual)</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">1</span>,myhash,myEqual)</span></span>;<br></code></pre></td></tr></table></figure><p>和以下效果等同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Strr</span><br><br>&#123;<br><br>  <span class="hljs-type">int</span> x;<br><br><br><br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Strr&amp; t) <span class="hljs-type">const</span><br><br>  &#123;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x==t.x;<br><br>  &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myhashfunction</span><br><br>&#123;<br><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Strr&amp; val)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  </span>&#123;<br><br>   <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(val.x);<br><br>  &#125;<br><br>&#125;;<br><br>std::unordered_set&lt;Strr,myhashfunction&gt; s2;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/17/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/03/17/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="动态内存基础"><a href="#动态内存基础" class="headerlink" title="动态内存基础"></a>动态内存基础</h2><p>栈内存：局部性、对象自动销毁</p><p>堆内存：运行期动态扩展、需要显式释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//两者的区别</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> *y=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//int *y = new int;合理 缺省初始化会随机分配数值，这其实就是两步，分配内存+构造对象</span><br><span class="hljs-keyword">delete</span> y;<br></code></pre></td></tr></table></figure><p> 对象的构造（对象的销毁与之类似）分为<strong>两步</strong>：</p><p><strong>1、分配内存  2、在所分配的内存上构造对象</strong></p><p><strong>new的几种常见形式</strong></p><ul><li>构建单一对象&#x2F;对象数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> * y = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> * y = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li>nothrow new</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * y = <span class="hljs-built_in">new</span>(std::nothrow) <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">//分配失败时不会抛出异常，且y指向nullptr</span><br></code></pre></td></tr></table></figure><ul><li><p>placement new   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> ch[<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)];<br><span class="hljs-type">int</span> *y = <span class="hljs-built_in">new</span> (ch) <span class="hljs-built_in">int</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//不要再次从堆上开辟内存，我这里已经分配好了内存空间，ch是首指针，这个指针所指向的内存空间是足够大的,显然这里ch指向的是栈内存</span><br><span class="hljs-comment">//这里代表的是 使用sizeof(int)确保ch数组可以容纳一个int类型的对象，然后把这个对象初始化为数值4</span><br></code></pre></td></tr></table></figure></li><li><p>new auto+new 对齐操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *y= <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//稍作修改</span><br><span class="hljs-type">int</span> *y=<span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">256</span>) Str&#123;&#125;<span class="hljs-comment">//定义Str的结构体，并使用alignas(256)进行对齐操作，这样的话，结构体实例的内存地址是256的倍数</span><br>Str * ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Str</span>();<br></code></pre></td></tr></table></figure></li><li><p>delete的常见用法</p><p>销毁单一对象&#x2F;对象数组 销毁的方式要对应好 <code>delete ptr /delete [] ptr;</code></p><p>placement delete </p></li><li><p>其他注意事项</p></li><li><p><strong>如果实在没有办法需要进行多次重复删除同一个指针，请在第一次删除后将指针置为nullptr</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">//不应重复删除，即使是nullptr，确保指针为nullptr(通常来讲，在删除之前，要判断一下是否为nullptr)</span><br></code></pre></td></tr></table></figure><p>delete不可以删除栈区的对象</p></li><li><p>借鉴C语言的内容</p><p>如果我们使用malloc新建对象，就要对应的使用free释放对象  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">delete</span> ptr;<br><br><span class="hljs-comment">//显然这里ptr的删除，指的是new申请的那段堆内存被删除掉了，ptr本身作为保存在栈内存中的一个变量，不会被删除</span><br></code></pre></td></tr></table></figure></li><li><p><strong>很细节的地方</strong></p></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> *ptr2 = ptr+<span class="hljs-number">1</span>;<br><span class="hljs-comment">//虽然这里的ptr2也是指针，但是不是new返回的指针，所以不可以使用delete删除</span><br></code></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>出现的背景：使用new与delete会存在问题：<strong>内存所有权不清晰、容易产生不销毁、多销毁的情况</strong></p><p>解决方案</p><p>auto_ptr(C++17删除)</p><p>直接使用<strong>shared_ptr &#x2F; unique_ptr &#x2F; weak_ptr</strong>,不要再使用new&#x2F;delete的裸指针</p><ul><li><p>shared_ptr（基于引用计数的共享内存解决方案）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> (<span class="hljs-number">3</span>))</span></span>;<span class="hljs-comment">//1</span><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; y=x;<span class="hljs-comment">//2,这里代表有5两个指针指向了那段内存</span><br></code></pre></td></tr></table></figure><p>调用析构函数时，在这里肯定是，y先调用析构函数，x再调用析构函数，每调用依次，计数减一，到0时标明不会再使用这片内存。</p></li></ul><p>指针的使用</p><p>方式一*x  </p><p>方式二x. get()</p><p>方式三x.reset(new int (4))&#x2F;x.reset( (int *) nullptr )</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;Call delete fun\n&quot;</span>;<br><span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),fun)</span></span>;<span class="hljs-comment">//自定义析构函数，默认状态下是缺省的析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; x = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>);<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>))</span></span>;<br></code></pre></td></tr></table></figure><p><strong>这是单个对象，那数组呢？</strong></p><p>C++17支持shared_ptr&lt;T[]&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">x</span> <span class="hljs-params">( <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>] )</span></span>;<br></code></pre></td></tr></table></figure><p>C++20支持make_shared分配数组</p><p>auto  x &#x3D; std::make_shared&lt;int [5]&gt;();</p><p>问题1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span> <span class="hljs-params">( <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>] )</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">y</span> <span class="hljs-params">(x.get())</span></span>;<span class="hljs-comment">//可以是x，但不能是x.get(),这个是原始指针，而不是智能指针</span><br></code></pre></td></tr></table></figure><p>问题2</p><p>将同一个原始指针 <code>ptr</code> 初始化为两个不同的 <code>std::shared_ptr&lt;int&gt;</code> 对象 <code>y</code> 和 <code>z</code>。这会导致问题，因为 <code>std::shared_ptr</code> 会对同一个资源进行引用计数，而在这种情况下，两个 <code>std::shared_ptr</code> 将会对同一个动态分配的内存进行管理，但是当其中一个 <code>std::shared_ptr</code> 被销毁时，它会尝试释放这个内存，而另一个 <code>std::shared_ptr</code> 也会对这块内存进行操作，这样就会导致内存的重复释放，从而导致程序崩溃或者其他未定义行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>);<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">y</span><span class="hljs-params">(ptr)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>应改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>))</span></span>;<br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; z = y; <span class="hljs-comment">// 或者 std::shared_ptr&lt;int&gt; z(y);</span><br></code></pre></td></tr></table></figure><p><strong>unique_ptr</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr <span class="hljs-comment">//独占内存的解决方案，不支持复制，但可以移动</span><br><br><span class="hljs-comment">//构造方式  </span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>))</span></span>;<br><span class="hljs-keyword">auto</span> y = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>);<br><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; y=x;<span class="hljs-comment">//这里是共享内存的要求，是不被允许的。</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; z=std::<span class="hljs-built_in">move</span>(x);<span class="hljs-comment">//这是移动，不是共享内存，是可以的。</span><br><br><br><span class="hljs-comment">//针对shared_ptr,这显然是合理的，因为可以共享</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>))</span></span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; x = <span class="hljs-built_in">fun</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//换一下 来到unique_ptr,看似没有区别，其实这里是合理的，这里不是共享，而是移动（不会产生额外的拷贝）</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>))</span></span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; x = <span class="hljs-built_in">fun</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特殊点：指定回收逻辑</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;Call delete fun\n&quot;</span>;<br><span class="hljs-keyword">delete</span> ptr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(&amp;fun)</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),fun)</span></span>;<span class="hljs-comment">//和shared_ptr有些不同  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一种</p><p>weak_ptr 防止循环引用而引入的智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++">Struct Str<br>&#123;<br>std::shared_ptr&lt;Str&gt; nei;<span class="hljs-comment">//私有物品，访问时就确定了所有权</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Str&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Str)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Str&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Str)</span></span>;<br>    x-&gt;nei=y;<span class="hljs-comment">//增加了y的引用计数（保存了y指向的那片内存的引用次数）</span><br>    y-&gt;nei=x;<span class="hljs-comment">//增加了x的引用计数</span><br>&#125;<br><span class="hljs-comment">//这里会产生循环引用，内存不会删除掉</span><br><span class="hljs-comment">//原因引用计数最后执行完是1，而不是0</span><br><br><br>Struct Str<br>&#123;<br>std::weak_ptr&lt;Str&gt; nei;<span class="hljs-comment">//共享仓库，都具有访问的权利，但是并不持有资源的所有权</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Str&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Str)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Str&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Str)</span></span>;<br>    <span class="hljs-comment">//下面两行不再增加引用计数</span><br>    x-&gt;nei=y;<br>    y-&gt;nei=x;<br>&#125;<br></code></pre></td></tr></table></figure><p>困惑的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++">Struct Str<br>&#123;<br>std::weak_ptr&lt;Str&gt; nei;<span class="hljs-comment">//共享仓库，都具有访问的权利，但是并不持有资源的所有权</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::shared_ptr&lt;Str&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Str)</span></span>;<br>&#123;<span class="hljs-comment">//域内</span><br>    <span class="hljs-function">std::shared_ptr&lt;Str&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Str)</span></span>;<br>    x-&gt;nei = y;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> ptr=x-&gt;nei.<span class="hljs-built_in">lock</span>();ptr)<span class="hljs-comment">//显然weak指针观察的资源已经被销毁，因为在域内，weak指针观察的资源和y指向的资源是同一个。</span><br>&#123;<br>    <span class="hljs-comment">//真</span><br>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//调用“假”这一部分，返回了一个空的std::shared_ptr</span><br>&#123;<br>    <span class="hljs-comment">//假</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//x-&gt;nei.lock()是在尝试获取被 std::weak_ptr 所观察的资源的 std::shared_ptr 指针</span><br></code></pre></td></tr></table></figure><h2 id="动态内存的相关内容"><a href="#动态内存的相关内容" class="headerlink" title="动态内存的相关内容"></a>动态内存的相关内容</h2><ol><li><p>sizeof不会返回动态分配的内存大小,例:sizeof(std::vector<int> x)是不会随着数组x加入了多少元素而变化内存的大小，原因（sizeof运算符在编译时计算数据类型或对象的大小）</p></li><li><pre><code class="C++">//分配器std::allocator &lt;int&gt; al;int *ptr = al.allocate(3);//这里只分配了内存，但是没有进行初始化或赋值的操作al.deallocate(ptr,3);</code></pre></li><li><p>使用malloc&#x2F;free来管理内存(C语言引入)</p></li><li><p>使用aligned_alloc进行对齐分配（C语言引入）</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/06/MIT6.824/"/>
    <url>/2024/03/06/MIT6.824/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实验组成：</p><p>lab1—Mapduce</p><p>lab2—Raft</p><p>lab3—k&#x2F;v server</p><p>lab4—分片的key-value服务</p><p>基础架构：</p><p>stroage存储 </p><p>Communition通信</p><p>Computation计算</p><p>关键点</p><p>RPC（远程过程调用）、threads、锁</p><p>Performance性能：scalability(可扩展性)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/05/pro_define/"/>
    <url>/2024/03/05/pro_define/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语言性能"><a href="#C-语言性能" class="headerlink" title="C++语言性能"></a>C++语言性能</h1><p>特点如下：</p><p>1、不确定大端法还是小端法，原因：与底层硬件紧密结合</p><p>2、对象生命周期的精确控制</p><p>3、Zero-overhead  abstraction</p><p>包括两点：</p><p>虚函数（不需要为没有使用的语言特性付出成本）</p><p>仅用某些函数特性不会额外付出性能（被编译器优化了）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>听课笔记</title>
    <link href="/2024/01/06/net-work/"/>
    <url>/2024/01/06/net-work/</url>
    
    <content type="html"><![CDATA[<h1 id="P39类型转换："><a href="#P39类型转换：" class="headerlink" title="P39类型转换："></a>P39类型转换：</h1><h2 id="1、注意区别-类型提升、类型转换"><a href="#1、注意区别-类型提升、类型转换" class="headerlink" title="1、注意区别 类型提升、类型转换"></a>1、注意区别 类型提升、类型转换</h2><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">void</span> *v =ptr;<br><br><span class="hljs-type">int</span> *ptr2=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(v)<br></code></pre></td></tr></table></figure><p>对于安全的显示类型转换 有 dynamic_cast</p><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>对于常量型指针,转化为非常量型的指针，但是仍是不安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr;<br><br><span class="hljs-keyword">const_cast</span> &lt;<span class="hljs-type">int</span>*&gt;(ptr);<br></code></pre></td></tr></table></figure><p>对于常量型引用，切记引用的最初，就应该是变量而不是常量，像这种常量，能过编译器，但是还是存在问题。</p><img src="https://pic.imgdb.cn/item/659cfb70871b83018a963025.png" alt="image-20240108110427548.png"><p>系统输出3，而不是4，因为系统直接进行替换，而不是修改。</p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">reinterpret_cast</span>&lt;&gt;()<span class="hljs-comment">//用于重新解释</span><br></code></pre></td></tr></table></figure><p>请注意，这里的重新解释，针对指针，而不是普通变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> *ptr=&amp;x;<br><span class="hljs-type">double</span> *ptr2=<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(ptr);<span class="hljs-comment">//这就相当于将地址变量补位了，double类型会变，float类型不会变，但是均不是我想要的</span><br></code></pre></td></tr></table></figure><h2 id="5、C类型转换"><a href="#5、C类型转换" class="headerlink" title="5、C类型转换"></a>5、C类型转换</h2><p>(double)3 这就是C类型转换，系统就会依次性的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">static_cast</span>,<br><span class="hljs-built_in">static_cast</span>(扩展)+<span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>+<span class="hljs-keyword">const_cast</span>.<br></code></pre></td></tr></table></figure><h1 id="P40算术操作符"><a href="#P40算术操作符" class="headerlink" title="P40算术操作符"></a>P40算术操作符</h1><h2 id="1、一元操作符（有关于数据类型）"><a href="#1、一元操作符（有关于数据类型）" class="headerlink" title="1、一元操作符（有关于数据类型）"></a>1、一元操作符（有关于数据类型）</h2><p>int a[3]&#x3D;{1,2,3};</p><p>const auto &amp;x&#x3D;+a;</p><p>这样的话，解释过来，int * const &amp; x &#x3D; +a;</p><p>请注意  顺序依次是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x=a;<br><span class="hljs-keyword">auto</span> &amp;x=a;<br><span class="hljs-keyword">auto</span> &amp;x=+a;<span class="hljs-comment">//这样会编译错误</span><br>必须是<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;x=+a <span class="hljs-comment">// int * const &amp; x = +a;</span><br>如果没有+<br>解释出来后，就出现了<span class="hljs-type">int</span> <span class="hljs-type">const</span> （&amp;x）[<span class="hljs-number">3</span>]=a;也就是没有类型转换了<br></code></pre></td></tr></table></figure><h2 id="2、一元操作符（整数类型提升，integral-promotion）"><a href="#2、一元操作符（整数类型提升，integral-promotion）" class="headerlink" title="2、一元操作符（整数类型提升，integral promotion）"></a>2、一元操作符（整数类型提升，integral promotion）</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">short <span class="hljs-attribute">x</span>=3;<br>auto <span class="hljs-attribute">y</span>=+3;//此时，int y= static_cast&lt;int&gt; (x);<br></code></pre></td></tr></table></figure><h2 id="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"><a href="#3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作" class="headerlink" title="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"></a>3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作</h2><h2 id="4、满足（m-n-m-n-m"><a href="#4、满足（m-n-m-n-m" class="headerlink" title="4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m"></a>4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m</h2><h1 id="P48-语句基础"><a href="#P48-语句基础" class="headerlink" title="P48 语句基础"></a>P48 语句基础</h1><h2 id="1、顺序语句和非顺序语句"><a href="#1、顺序语句和非顺序语句" class="headerlink" title="1、顺序语句和非顺序语句"></a>1、顺序语句和非顺序语句</h2><p>一般来讲,顺序语句（硬件流水线有关）会比非顺序语句执行速度快</p><h2 id="2、典型非顺序语句：goto"><a href="#2、典型非顺序语句：goto" class="headerlink" title="2、典型非顺序语句：goto"></a>2、典型非顺序语句：goto</h2><p>不能跨函数跳转 、向前跳转不能越过对象初始化语句、向后跳转（向后是指向上）可能会导致对象销毁与重新初始化</p><h2 id="3、分支语句"><a href="#3、分支语句" class="headerlink" title="3、分支语句"></a>3、分支语句</h2><p>稍作特殊记录</p><p>1、这样就是编译器就可以确定,优化了很多部分的代码，所以节省时间，提高了效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> grade =<span class="hljs-number">59</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(grade&lt;<span class="hljs-number">60</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure><p>2、条件框内,可以使用初始化，这样的话变量的生命周期就可控了</p><p>if(int y&#x3D;x*3;y&gt;100)</p><p>&#96;&#96;</p><h2 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h2><p>C++17之后，</p><p>switch(std::cin&gt;&gt;x;x)</p><p>{</p><p>case 4:</p><p>break；</p><p>&#x2F;&#x2F;int y&#x3D;4; 这样是不可以的，因为这是一个整体的Switch代码，是不可以简单的定义的变量。</p><p>&#x2F;&#x2F;但是如果你非得定义，需要大括号</p><p>case 4：</p><p>{</p><p>int y&#x3D;4；</p><p>break；</p><p>}</p><p>case 5：</p><p>break；</p><p>}</p><p>为进一步防止 break缺失引出的问题，我们可以在编译器的设置中添加，Wimplicit-fallthrough</p><p>当然 如果我们希望3执行完后执行4，然后并不需要提醒我，使用[[fallthrough]];即可 （C++17以后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;3&quot;</span>&lt;&lt;std::endl;<br>    [[fallthrough]];<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;4&quot;</span>&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><h2 id="4、while语句"><a href="#4、while语句" class="headerlink" title="4、while语句"></a>4、while语句</h2><p>C语言不可以、C++17之前不行，C++17之后，while（判断条件中可以存在初始化语句）</p><p>再有就是do-while&#x2F;while&#x2F;for三者的细微区别，略过。</p><p>需要注意的是</p><p>for循环中初始化语句，仅可以声明同类型的变量</p><p>请注意（同一行）<br>int x&#x3D;3，*p&#x3D;&x;</p><p>int *x,q;&#x2F;&#x2F;x为指针，但是q是整型int，所以容易存在误解！</p><p>新增部分，基于范围的for循环</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本质：语法糖，编译器会转换为for循环的调用方式（c++17之后，这个转换方式改变了，之前是</p><p>auto _begin&#x3D; 首表达式,   _end&#x3D;尾表达式，上文提到的那个问题，这样声明是可能会存在歧义的。<br>）</p><p><img src="https://pic.imgdb.cn/item/65b8a537871b83018a41c163.jpg"></p><p>看似安全的C++17，范围表达式还是有可能出现问题。</p><p>问题如下：</p><p><img src="https://pic.imgdb.cn/item/65b8b60d871b83018a7480e2.jpg"></p><p>所以C++20开始，在范围表达式之前增加了初始化语句。</p><p>还有一点，使用常量左值引用读元素，</p><ul><li>引用  可以加快遍历速度，不需要拷贝</li><li>常引用，就满足了不会修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>再通俗一点，这里就需要使用</p><p>const auto &amp; v</p><p><strong>但是如果是修改元素，直接去掉const，而使用auto &amp; v,是会报错的，</strong></p><p>举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v = v + <span class="hljs-number">1</span>;<br>std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上没有问题</p><p>以下出现问题，我们使用万能引用来解决这个问题，**<u>auto &amp;&amp;v</u>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector &lt;<span class="hljs-type">bool</span>&gt; arr&#123;<span class="hljs-literal">true</span>，<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v=<span class="hljs-literal">false</span>;<br>&#125;<br>会报错<br>我们应当使用<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;v : arr) &#123;<br>v=<span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-达夫设备—语句的综合应用"><a href="#5-达夫设备—语句的综合应用" class="headerlink" title="5.达夫设备—语句的综合应用"></a>5.达夫设备—语句的综合应用</h2><p>其实也就是switch里面套循环，这里的例子套的循环为for循环</p><p>核心就是switch语句先跳转case处理，那部分特殊的数据（例：不能整除的数据，这里的不能整除指的是100001，每8个进行一次，那个单独的数据），然后后面就是正常的for循环处理可以整除的部分</p><ol><li><p>循环展开,但是容易产生内存越界，举例，如果这里的n是10001，那么i&#x3D;10000时，再次进入循环，执行8次max…,就会产生越界！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>（<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>；i&lt;n; i++）&#123;max... &#125;;<br><br>改为<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i+=<span class="hljs-number">8</span>)      &#123;max... <span class="hljs-number">8</span>次&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>最直观的解决方案就是，0—9999这些，正常处理，但是10000 10001单独处理</p><p>后面单独处理的时候，还可以用指针进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (buffer_count % <span class="hljs-number">8</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>max_value = (max_value &gt; *ptr) ? max_value : *ptr;<br>++ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h2 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h2><h4 id="1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）"><a href="#1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）" class="headerlink" title="1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）"></a>1、可重复声明、但是不可以重复函数定义（原因：声明并不产生汇编代码）</h4><h4 id="2、C-函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）"><a href="#2、C-函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）" class="headerlink" title="2、C++函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）"></a>2、C++函数体在产生汇编代码时，要由函数名、形参类型等信息共同确定，相反，C函数体就可以仅靠函数名产生汇编代码（因为C语言不存在函数重载）</h4><p>要使C++语言转为C语言类型，需要在函数声明和函数定义之前均添加 extern “C”</p><p>这样的话，不支持重载、C类型的链接形式这两个特性就支持了。</p><p>提问：如果是函数重载呢？</p><p>答：一个加了extern “C”，另一个不加extern “C”，这样可以发生重载。</p><p>答：两个都加或者两个都不加，这样不可以进行重载。</p><h4 id="3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝"><a href="#3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝" class="headerlink" title="3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝"></a>3、函数的调用，存在两步拷贝，第一步，传入时拷贝，第二步，传出（返回时）拷贝</h4><p>栈帧结构：函数体所对应的存储结构</p><p><img src="https://pic.imgdb.cn/item/65e6bf539f345e8d03c0d832.jpg"></p><h4 id="4、函数详解部分"><a href="#4、函数详解部分" class="headerlink" title="4、函数详解部分"></a>4、函数详解部分</h4><ul><li><p>零形参用void</p></li><li><p>非模版函数，每个形参有确定的类型，但可以无名称</p></li><li><p>实参到形参的拷贝求值顺序不定</p></li><li><p>C++17中强制省略 临时对象的复制</p></li><li><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Str per)</span></span>&#123;&#125;;+<span class="hljs-built_in">fun</span>(<span class="hljs-built_in">Str</span>());<br></code></pre></td></tr></table></figure></li><li><p>函数传参会产生类型退化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span>;<br>或<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> p[])</span></span>;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">fun</span>(a);<br></code></pre></td></tr></table></figure><p>那如果是二维数组呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> (*ptr) [<span class="hljs-number">4</span>])</span></span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">fun</span>(a);<br><span class="hljs-comment">//当形参部分是int par[100][20]的时候,int a[3][20];fun(a);这样是可以的</span><br><span class="hljs-comment">//但是当int a[3][4]时，就不可以使用fun(a)，因为列的大小不对应。</span><br></code></pre></td></tr></table></figure><p>那如果是引用呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">- <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;par)[<span class="hljs-number">3</span>])</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  </span>&#123;<br><br>  &#125;;<br><br>  <br><br>  <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];<br><br>  <span class="hljs-keyword">auto</span> &amp;b=a;<span class="hljs-comment">//b的类型为 int (&amp;) [3]</span><br><br>  <span class="hljs-built_in">fun</span>(a);<br></code></pre></td></tr></table></figure></li><li><p>最后一点：变长参数</p></li></ul><p>有三种类型</p><p>第一类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(std::initializer_list &lt;<span class="hljs-type">int</span>&gt; par)</span> </span>&#123;<span class="hljs-comment">//使用时，确保类型相同，实质 包含两个指针，开头与结尾</span><br><br>&#125;;<br><br><span class="hljs-built_in">fun</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br></code></pre></td></tr></table></figure><p>第二类 可变长度模版参数</p><p>第三类 使用省略号表示形式参数</p><ul><li><p>函数可以定义缺省实参</p><p>细节：</p><p>若某个形参具有缺省实参，那么它的右侧的形参都必须要有缺省实参</p><p>也即以下是不可以的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>xxx<br><br>&#125;<br></code></pre></td></tr></table></figure><p>缺省实参只能定义一次，例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> fun（<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>,<span class="hljs-type">int</span> z=<span class="hljs-number">3</span>);<span class="hljs-comment">//这里是声明，但是y和z都是缺省实参，都被定义过一次了</span><br></code></pre></td></tr></table></figure><p>在下面的函数定义时，就不可以再次定义y和z的缺省实参了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>,<span class="hljs-type">int</span> z=<span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>xxx;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>那下面这种情况为什么就合法呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z=<span class="hljs-number">3</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y=<span class="hljs-number">2</span>,<span class="hljs-type">int</span> z)</span></span>;<span class="hljs-comment">//因为这里z虽然没有定义缺省实参，但是上一行定义完了z的缺省实参</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>xxx;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在一个翻译单元中，每个形参的缺省实参只能定义一次，比较绕</p><p>缺省实参为对象时，实参的缺省值会随对象值的变化而变化</p></li><li><p>main函数的两个版本</p></li></ul><p>第二个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br></code></pre></td></tr></table></figure><h6 id="argv-0-代表的是调用可执行程序的方式"><a href="#argv-0-代表的是调用可执行程序的方式" class="headerlink" title="argv[0]代表的是调用可执行程序的方式"></a>argv[0]代表的是调用可执行程序的方式</h6><p><img src="https://pic.imgdb.cn/item/65e828f89f345e8d03494845.jpg"></p><h4 id="5、函数体部分详解"><a href="#5、函数体部分详解" class="headerlink" title="5、函数体部分详解"></a>5、函数体部分详解</h4><p>隐式返回&#x2F;显示返回</p><p>显示返回关键字： return</p><h5 id="return"><a href="#return" class="headerlink" title="return ;"></a>return ;</h5><p>return 表达式</p><p>return 初始化列表</p><p>例：</p><p>这段代码的问题在于，<code>std::initializer_list</code> 返回的是一个临时对象，而且它的生命周期是在当前表达式结束后即刻结束。在 <code>fun()</code> 函数返回后，临时的 <code>initializer_list</code> 对象就会被销毁，所以在 <code>main()</code> 函数中使用 <code>auto x = fun();</code> 赋值给 <code>x</code> 的是一个悬空的 <code>initializer_list</code>，使用 <code>x</code> 的行为是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::initializer_list &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">fun</span>()<br>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意  返回自动对象的引用或指针</p><p>返回值优化（RVO） C++17对返回临时对象的强制优化：系统会引入额外的参数，从而省略拷贝构造的过程。</p><p>例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Str <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br>&#123;<br>Str x;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br>int main()<br>&#123;<br>Str res = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//这里其实发生了两次拷贝构造</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6、函数的返回类型"><a href="#6、函数的返回类型" class="headerlink" title="6、函数的返回类型"></a>6、函数的返回类型</h4><p>函数返回的几种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">C++<span class="hljs-number">11</span> <span class="hljs-comment">//位于函数头的后部</span><br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> -&gt; <span class="hljs-type">int</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-comment">//初步看没什么不同，但是如果涉及到类的成员函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">S::fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> -&gt; Myint<span class="hljs-comment">//优先在S类内寻找Myint</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-function">S::Myint <span class="hljs-title">S::fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">C++<span class="hljs-number">14</span> <span class="hljs-comment">//自动推导</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//auto的类型是根据return语句来的，如果有多个return语句，要保持一致</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">//如何解决这个问题呢？答：constexpr</span><br><span class="hljs-comment">//例：</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">true</span>;<span class="hljs-comment">//这样的话 编译器根据value的值可以省略一部分，就不会出现多个return语句不一致的问题了</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p> 返回类型与结构化绑定（C++17）&#x2F;&#x2F;但并非所有的数据类型都可以结构化绑定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Str</span><br><br>&#123;<br><br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><br>&#125;<br><br><span class="hljs-function">Str <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">return</span> Str&#123;&#125;;<br><br>&#125;<br><br><span class="hljs-keyword">auto</span> [v1,v2] = <span class="hljs-built_in">fun</span>();<span class="hljs-comment">//这里可以直接访问v1，v2</span><br><br></code></pre></td></tr></table></figure><p>[[nodiscard]]属性（C++17）&#x2F;&#x2F;用来提示不应该丢弃返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">[[nodiscard]] int <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int a,int b)</span></span><br>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br>int main()<br>&#123;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7、函数重载"><a href="#7、函数重载" class="headerlink" title="7、函数重载"></a>7、函数重载</h4><p>使用相同的函数名定义多个函数，每个函数具有不同的参数列表</p><p>注意：不能基于不同的返回类型进行重载</p><p>name mangling,效果就是产生给编译器看的东西</p><p>重载解析：也即编译器如何选择正确的版本完成函数调用，使我们的函数重载解析时，尽可能的符合常识。</p><p>1、名称查找分为：(有它本身的缺点，例：会限定在域内，相当于固定了查找范围的优先级，可能造成不恰当的调用)</p><ul><li>限定查找：例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">::<span class="hljs-built_in">fun</span>();<span class="hljs-comment">//限定在全局去找，不会深入到类内</span><br>MyNS::<span class="hljs-built_in">fun</span>();<span class="hljs-comment">//限定在类内或域内进行查找</span><br></code></pre></td></tr></table></figure><p>非限定查找 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">fun</span>();<span class="hljs-comment">//直接调用会进行域的逐级查找</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br><span class="hljs-keyword">namespace</span> MyNS<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;xx&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyNS::<span class="hljs-built_in">g</span>();<span class="hljs-comment">//这里会调用到域内还是全局的fun，取决于g()函数和域内fun()函数的相对关系（位置）,实质</span><br>    <span class="hljs-comment">//就是编译器知道的顺序先后</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、实参依赖查找：只对自定义类型生效</p><p>对于重载解析的整体步骤，大致分为两部分</p><p>  <img src="https://pic.imgdb.cn/item/65f1574e9f345e8d03a02da7.png"></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// bool 转 int 就是promotion</span><br><span class="hljs-comment">// 1 转float 或 double 均是标准转换 </span><br></code></pre></td></tr></table></figure><h3 id="8、函数相关的其他内容"><a href="#8、函数相关的其他内容" class="headerlink" title="8、函数相关的其他内容"></a>8、函数相关的其他内容</h3><p>1、递归函数，以二分查找作为例子</p><p>2、内联函数（适用于较为简单的函数，编译器会直接调用展开,就不会涉及到后面的栈帧的建立、销毁）</p><p>即使我不加inline，编译器在针对翻译单元进行操作时，有时编译器也会直接展开函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于编译器而言，内联函数可以被编译器重复接受，并选择其中一个，不会报错</p><p>实质，就是翻译单元也要有一致性原则</p><p>3、constexpr 常量表达式，针对变量或者针对函数，使其在编译器就被确定</p><ul><li>constexpr函数（C++11起），既可以在编译期执行也可以在运行期执行。</li><li>consteval函数（C++20起），只能在编译期运行，强制在编译期执行，可以提升性能，但是函数体中不能出现在运行期间才可以执行的语句。</li></ul><p>数组类型与函数类型的联系与区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> K = <span class="hljs-type">int</span> [<span class="hljs-number">3</span>];<br>K a;<br><br><span class="hljs-keyword">using</span> K =<span class="hljs-built_in">int</span> (<span class="hljs-type">int</span>)<br>K fun;<span class="hljs-comment">//这样声明是可以的，等于int fun(int),但是不能继续定义</span><br><br></code></pre></td></tr></table></figure><p>接下来重点介绍  数组指针类型、函数指针类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> K = <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];<br>K* a;<span class="hljs-comment">//相当于int (*a) [3];一定注意，这里的括号，是不能省略int *a[3]//这样写的话，代表a[3]数组,数组元素的类型为int *</span><br><br><br><span class="hljs-keyword">using</span> K = <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>);<br>K * fun;<span class="hljs-comment">//一定要注意，这里的fun，就不再是函数声明、而是变量、而是指针</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dec</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">///</span><br>&#125;<br>fun = &amp;dec;<span class="hljs-comment">//这样的话，就有了一个典型的函数指针，调用时就可以使用(*fun) (100)</span><br><span class="hljs-comment">//既然是函数指针，也就可以作为函数的参数</span><br><span class="hljs-comment">//我来写一个高级函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Twice</span><span class="hljs-params">(K *fun,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp=(*fun)(x);<br>    <span class="hljs-keyword">return</span> tmp*<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//再来一个</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">transform</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),a.<span class="hljs-built_in">begin</span>(),&amp;dec);<br><span class="hljs-comment">//相当于就是a数组中的每个元素，依次调用dec函数</span><br></code></pre></td></tr></table></figure><p><strong>4、函数指针与重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><span class="hljs-keyword">auto</span> x = fun;<span class="hljs-comment">//这样就会产生歧义</span><br><span class="hljs-comment">//可以改用以下</span><br><span class="hljs-keyword">using</span> K=<span class="hljs-built_in">void</span> (<span class="hljs-type">int</span>)<br>K* x=fun;<br></code></pre></td></tr></table></figure><p><strong>5、函数指针作返回值</strong><br>与数组类似，函数返回与数组返回，均不能返回函数本身、数组本身，因为数组与函数均不可以复制，那么返回的自然是数组指针或者函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">bool</span> input)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(input)<br><span class="hljs-keyword">return</span> inc;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> dec;<br>&#125;<br><br>std::cout&lt;&lt;(*<span class="hljs-built_in">fun</span>(<span class="hljs-literal">true</span>))(<span class="hljs-number">100</span>)&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
