<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>听课笔记</title>
    <link href="/2024/01/06/net-work/"/>
    <url>/2024/01/06/net-work/</url>
    
    <content type="html"><![CDATA[<h1 id="P39类型转换："><a href="#P39类型转换：" class="headerlink" title="P39类型转换："></a>P39类型转换：</h1><h2 id="1、注意区别-类型提升、类型转换"><a href="#1、注意区别-类型提升、类型转换" class="headerlink" title="1、注意区别 类型提升、类型转换"></a>1、注意区别 类型提升、类型转换</h2><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">void</span> *v =ptr;<br><br><span class="hljs-type">int</span> *ptr2=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(v)<br></code></pre></td></tr></table></figure><p>对于安全的显示类型转换 有 dynamic_cast</p><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>对于常量型指针,转化为非常量型的指针，但是仍是不安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr;<br><br><span class="hljs-keyword">const_cast</span> &lt;<span class="hljs-type">int</span>*&gt;(ptr);<br></code></pre></td></tr></table></figure><p>对于常量型引用，切记引用的最初，就应该是变量而不是常量，像这种常量，能过编译器，但是还是存在问题。</p><img src="https://pic.imgdb.cn/item/659cfb70871b83018a963025.png" alt="image-20240108110427548.png"><p>系统输出3，而不是4，因为系统直接进行替换，而不是修改。</p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">reinterpret_cast</span>&lt;&gt;()<span class="hljs-comment">//用于重新解释</span><br></code></pre></td></tr></table></figure><p>请注意，这里的重新解释，针对指针，而不是普通变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> *ptr=&amp;x;<br><span class="hljs-type">double</span> *ptr2=<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(ptr);<span class="hljs-comment">//这就相当于将地址变量补位了，double类型会变，float类型不会变，但是均不是我想要的</span><br></code></pre></td></tr></table></figure><h2 id="5、C类型转换"><a href="#5、C类型转换" class="headerlink" title="5、C类型转换"></a>5、C类型转换</h2><p>(double)3 这就是C类型转换，系统就会依次性的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">static_cast</span>,<br><span class="hljs-built_in">static_cast</span>(扩展)+<span class="hljs-keyword">const_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>,<br><span class="hljs-keyword">reinterpret_cast</span>+<span class="hljs-keyword">const_cast</span>.<br></code></pre></td></tr></table></figure><h1 id="P40算术操作符"><a href="#P40算术操作符" class="headerlink" title="P40算术操作符"></a>P40算术操作符</h1><h2 id="1、一元操作符（有关于数据类型）"><a href="#1、一元操作符（有关于数据类型）" class="headerlink" title="1、一元操作符（有关于数据类型）"></a>1、一元操作符（有关于数据类型）</h2><p>int a[3]&#x3D;{1,2,3};</p><p>const auto &amp;x&#x3D;+a;</p><p>这样的话，解释过来，int * const &amp; x &#x3D; +a;</p><p>请注意  顺序依次是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x=a;<br><span class="hljs-keyword">auto</span> &amp;x=a;<br><span class="hljs-keyword">auto</span> &amp;x=+a;<span class="hljs-comment">//这样会编译错误</span><br>必须是<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;x=+a <span class="hljs-comment">// int * const &amp; x = +a;</span><br>如果没有+<br>解释出来后，就出现了<span class="hljs-type">int</span> <span class="hljs-type">const</span> （&amp;x）[<span class="hljs-number">3</span>]=a;也就是没有类型转换了<br></code></pre></td></tr></table></figure><h2 id="2、一元操作符（整数类型提升，integral-promotion）"><a href="#2、一元操作符（整数类型提升，integral-promotion）" class="headerlink" title="2、一元操作符（整数类型提升，integral promotion）"></a>2、一元操作符（整数类型提升，integral promotion）</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">short <span class="hljs-attribute">x</span>=3;<br>auto <span class="hljs-attribute">y</span>=+3;//此时，int y= static_cast&lt;int&gt; (x);<br></code></pre></td></tr></table></figure><h2 id="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"><a href="#3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作" class="headerlink" title="3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作"></a>3、整数相除会产生整数，向0取整，求余仅接受整数，符号参照第一个操作</h2><h2 id="4、满足（m-n-m-n-m"><a href="#4、满足（m-n-m-n-m" class="headerlink" title="4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m"></a>4、满足（m&#x2F;n)+(m%n)&#x3D;&#x3D;m</h2><h1 id="P48-语句基础"><a href="#P48-语句基础" class="headerlink" title="P48 语句基础"></a>P48 语句基础</h1><h2 id="1、顺序语句和非顺序语句"><a href="#1、顺序语句和非顺序语句" class="headerlink" title="1、顺序语句和非顺序语句"></a>1、顺序语句和非顺序语句</h2><p>一般来讲,顺序语句（硬件流水线有关）会比非顺序语句执行速度快</p><h2 id="2、典型非顺序语句：goto"><a href="#2、典型非顺序语句：goto" class="headerlink" title="2、典型非顺序语句：goto"></a>2、典型非顺序语句：goto</h2><p>不能跨函数跳转 、向前跳转不能越过对象初始化语句、向后跳转（向后是指向上）可能会导致对象销毁与重新初始化</p><h2 id="3、分支语句"><a href="#3、分支语句" class="headerlink" title="3、分支语句"></a>3、分支语句</h2><p>稍作特殊记录</p><p>1、这样就是编译器就可以确定,优化了很多部分的代码，所以节省时间，提高了效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> grade =<span class="hljs-number">59</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(grade&lt;<span class="hljs-number">60</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure><p>2、条件框内,可以使用初始化，这样的话变量的生命周期就可控了</p><p>if(int y&#x3D;x*3;y&gt;100)</p><p>&#96;&#96;</p><h2 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h2><p>C++17之后，</p><p>switch(std::cin&gt;&gt;x;x)</p><p>{</p><p>case 4:</p><p>break；</p><p>&#x2F;&#x2F;int y&#x3D;4; 这样是不可以的，因为这是一个整体的Switch代码，是不可以简单的定义的变量。</p><p>&#x2F;&#x2F;但是如果你非得定义，需要大括号</p><p>case 4：</p><p>{</p><p>int y&#x3D;4；</p><p>break；</p><p>}</p><p>case 5：</p><p>break；</p><p>}</p><p>为进一步防止 break缺失引出的问题，我们可以在编译器的设置中添加，Wimplicit-fallthrough</p><p>当然 如果我们希望3执行完后执行4，然后并不需要提醒我，使用[[fallthrough]];即可 （C++17以后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;3&quot;</span>&lt;&lt;std::endl;<br>    [[fallthrough]];<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;4&quot;</span>&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><h2 id="4、while语句"><a href="#4、while语句" class="headerlink" title="4、while语句"></a>4、while语句</h2><p>C语言不可以、C++17之前不行，C++17之后，while（判断条件中可以存在初始化语句）</p><p>再有就是do-while&#x2F;while&#x2F;for三者的细微区别，略过。</p><p>需要注意的是</p><p>for循环中初始化语句，仅可以声明同类型的变量</p><p>请注意（同一行）<br>int x&#x3D;3，*p&#x3D;&x;</p><p>int *x,q;&#x2F;&#x2F;x为指针，但是q是整型int，所以容易存在误解！</p><p>新增部分，基于范围的for循环</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>本质：语法糖，编译器会转换为for循环的调用方式（c++17之后，这个转换方式改变了，之前是</p><p>auto _begin&#x3D; 首表达式,   _end&#x3D;尾表达式，上文提到的那个问题，这样声明是可能会存在歧义的。<br>）</p><p><img src="https://pic.imgdb.cn/item/65b8a537871b83018a41c163.jpg"></p><p>看似安全的C++17，范围表达式还是有可能出现问题。</p><p>问题如下：</p><p><img src="https://pic.imgdb.cn/item/65b8b60d871b83018a7480e2.jpg"></p><p>所以C++20开始，在范围表达式之前增加了初始化语句。</p><p>还有一点，使用常量左值引用读元素，</p><ul><li>引用  可以加快遍历速度，不需要拷贝</li><li>常引用，就满足了不会修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; v:arr)<br><br>std::cout&lt;&lt;v&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>再通俗一点，这里就需要使用</p><p>const auto &amp; v</p><p><strong>但是如果是修改元素，直接去掉const，而使用auto &amp; v,是会报错的，</strong></p><p>举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector &lt;<span class="hljs-type">int</span>&gt; arr&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : arr) &#123;<br>v = v + <span class="hljs-number">1</span>;<br>std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上没有问题</p><p>以下出现问题，我们使用万能引用来解决这个问题，**<u>auto &amp;&amp;v</u>**</p><pre><code class="hljs">std::vector &lt;bool&gt; arr&#123;true，false&#125;;for (auto &amp;v : arr) &#123;    v=false;&#125;会报错我们应当使用for (auto &amp;&amp;v : arr) &#123;    v=false;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/04/hello-world/"/>
    <url>/2024/01/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
